{"ast":null,"code":"/**\n * @author Kate\n */\nvar tracery = function () {\n  var TraceryNode = function (parent, childIndex, settings) {\n    this.errors = []; // No input? Add an error, but continue anyways\n\n    if (settings.raw === undefined) {\n      this.errors.push(\"Empty input for node\");\n      settings.raw = \"\";\n    } // If the root node of an expansion, it will have the grammar passed as the 'parent'\n    //  set the grammar from the 'parent', and set all other values for a root node\n\n\n    if (parent instanceof tracery.Grammar) {\n      this.grammar = parent;\n      this.parent = null;\n      this.depth = 0;\n      this.childIndex = 0;\n    } else {\n      this.grammar = parent.grammar;\n      this.parent = parent;\n      this.depth = parent.depth + 1;\n      this.childIndex = childIndex;\n    }\n\n    this.raw = settings.raw;\n    this.type = settings.type;\n    this.isExpanded = false;\n\n    if (!this.grammar) {\n      this.errors.push(\"No grammar specified for this node \" + this);\n    }\n  };\n\n  TraceryNode.prototype.toString = function () {\n    return \"Node('\" + this.raw + \"' \" + this.type + \" d:\" + this.depth + \")\";\n  }; // Expand the node (with the given child rule)\n  //  Make children if the node has any\n\n\n  TraceryNode.prototype.expandChildren = function (childRule, preventRecursion) {\n    this.children = [];\n    this.finishedText = \"\"; // Set the rule for making children,\n    // and expand it into section\n\n    this.childRule = childRule;\n\n    if (this.childRule !== undefined) {\n      var sections = tracery.parse(childRule); // Add errors to this\n\n      if (sections.errors.length > 0) {\n        this.errors = this.errors.concat(sections.errors);\n      }\n\n      for (var i = 0; i < sections.length; i++) {\n        this.children[i] = new TraceryNode(this, i, sections[i]);\n        if (!preventRecursion) this.children[i].expand(preventRecursion); // Add in the finished text\n\n        this.finishedText += this.children[i].finishedText;\n      }\n    } else {\n      // In normal operation, this shouldn't ever happen\n      this.errors.push(\"No child rule provided, can't expand children\");\n    }\n  }; // Expand this rule (possibly creating children)\n\n\n  TraceryNode.prototype.expand = function (preventRecursion) {\n    if (!this.isExpanded) {\n      this.isExpanded = true;\n      this.expansionErrors = []; // Types of nodes\n      // -1: raw, needs parsing\n      //  0: Plaintext\n      //  1: Tag (\"#symbol.mod.mod2.mod3#\" or \"#[pushTarget:pushRule]symbol.mod\")\n      //  2: Action (\"[pushTarget:pushRule], [pushTarget:POP]\", more in the future)\n\n      switch (this.type) {\n        // Raw rule\n        case -1:\n          this.expandChildren(this.raw, preventRecursion);\n          break;\n        // plaintext, do nothing but copy text into finsihed text\n\n        case 0:\n          this.finishedText = this.raw;\n          break;\n        // Tag\n\n        case 1:\n          // Parse to find any actions, and figure out what the symbol is\n          this.preactions = [];\n          this.postactions = [];\n          var parsed = tracery.parseTag(this.raw); // Break into symbol actions and modifiers\n\n          this.symbol = parsed.symbol;\n          this.modifiers = parsed.modifiers; // Create all the preactions from the raw syntax\n\n          for (var i = 0; i < parsed.preactions.length; i++) {\n            this.preactions[i] = new NodeAction(this, parsed.preactions[i].raw);\n          }\n\n          for (var i = 0; i < parsed.postactions.length; i++) {//   this.postactions[i] = new NodeAction(this, parsed.postactions[i].raw);\n          } // Make undo actions for all preactions (pops for each push)\n\n\n          for (var i = 0; i < this.preactions.length; i++) {\n            if (this.preactions[i].type === 0) this.postactions.push(this.preactions[i].createUndo());\n          } // Activate all the preactions\n\n\n          for (var i = 0; i < this.preactions.length; i++) {\n            this.preactions[i].activate();\n          }\n\n          this.finishedText = this.raw; // Expand (passing the node, this allows tracking of recursion depth)\n\n          var selectedRule = this.grammar.selectRule(this.symbol, this, this.errors);\n          this.expandChildren(selectedRule, preventRecursion); // Apply modifiers\n          // TODO: Update parse function to not trigger on hashtags within parenthesis within tags,\n          //   so that modifier parameters can contain tags \"#story.replace(#protagonist#, #newCharacter#)#\"\n\n          for (var i = 0; i < this.modifiers.length; i++) {\n            var modName = this.modifiers[i];\n            var modParams = [];\n\n            if (modName.indexOf(\"(\") > 0) {\n              var regExp = /\\(([^)]+)\\)/; // Todo: ignore any escaped commas.  For now, commas always split\n\n              var results = regExp.exec(this.modifiers[i]);\n\n              if (!results || results.length < 2) {} else {\n                var modParams = results[1].split(\",\");\n                modName = this.modifiers[i].substring(0, modName.indexOf(\"(\"));\n              }\n            }\n\n            var mod = this.grammar.modifiers[modName]; // Missing modifier?\n\n            if (!mod) {\n              this.errors.push(\"Missing modifier \" + modName);\n              this.finishedText += \"((.\" + modName + \"))\";\n            } else {\n              this.finishedText = mod(this.finishedText, modParams);\n            }\n          } // Perform post-actions\n\n\n          for (var i = 0; i < this.postactions.length; i++) {\n            this.postactions[i].activate();\n          }\n\n          break;\n\n        case 2:\n          // Just a bare action?  Expand it!\n          this.action = new NodeAction(this, this.raw);\n          this.action.activate(); // No visible text for an action\n          // TODO: some visible text for if there is a failure to perform the action?\n\n          this.finishedText = \"\";\n          break;\n      }\n    } else {//console.warn(\"Already expanded \" + this);\n    }\n  };\n\n  TraceryNode.prototype.clearEscapeChars = function () {\n    this.finishedText = this.finishedText.replace(/\\\\\\\\/g, \"DOUBLEBACKSLASH\").replace(/\\\\/g, \"\").replace(/DOUBLEBACKSLASH/g, \"\\\\\");\n  }; // An action that occurs when a node is expanded\n  // Types of actions:\n  // 0 Push: [key:rule]\n  // 1 Pop: [key:POP]\n  // 2 function: [functionName(param0,param1)] (TODO!)\n\n\n  function NodeAction(node, raw) {\n    /*\n     if (!node)\n     console.warn(\"No node for NodeAction\");\n     if (!raw)\n     console.warn(\"No raw commands for NodeAction\");\n     */\n    this.node = node;\n    var sections = raw.split(\":\");\n    this.target = sections[0]; // No colon? A function!\n\n    if (sections.length === 1) {\n      this.type = 2;\n    } // Colon? It's either a push or a pop\n    else {\n      this.rule = sections[1];\n\n      if (this.rule === \"POP\") {\n        this.type = 1;\n      } else {\n        this.type = 0;\n      }\n    }\n  }\n\n  NodeAction.prototype.createUndo = function () {\n    if (this.type === 0) {\n      return new NodeAction(this.node, this.target + \":POP\");\n    } // TODO Not sure how to make Undo actions for functions or POPs\n\n\n    return null;\n  };\n\n  NodeAction.prototype.activate = function () {\n    var grammar = this.node.grammar;\n\n    switch (this.type) {\n      case 0:\n        // split into sections (the way to denote an array of rules)\n        this.ruleSections = this.rule.split(\",\");\n        this.finishedRules = [];\n        this.ruleNodes = [];\n\n        for (var i = 0; i < this.ruleSections.length; i++) {\n          var n = new TraceryNode(grammar, 0, {\n            type: -1,\n            raw: this.ruleSections[i]\n          });\n          n.expand();\n          this.finishedRules.push(n.finishedText);\n        } // TODO: escape commas properly\n\n\n        grammar.pushRules(this.target, this.finishedRules, this);\n        break;\n\n      case 1:\n        grammar.popRules(this.target);\n        break;\n\n      case 2:\n        grammar.flatten(this.target, true);\n        break;\n    }\n  };\n\n  NodeAction.prototype.toText = function () {\n    switch (this.type) {\n      case 0:\n        return this.target + \":\" + this.rule;\n\n      case 1:\n        return this.target + \":POP\";\n\n      case 2:\n        return \"((some function))\";\n\n      default:\n        return \"((Unknown Action))\";\n    }\n  }; // Sets of rules\n  // Can also contain conditional or fallback sets of rulesets)\n\n\n  function RuleSet(grammar, raw) {\n    this.raw = raw;\n    this.grammar = grammar;\n    this.falloff = 1;\n\n    if (Array.isArray(raw)) {\n      this.defaultRules = raw;\n    } else if (typeof raw === 'string' || raw instanceof String) {\n      this.defaultRules = [raw];\n    } else if (raw === 'object') {// TODO: support for conditional and hierarchical rule sets\n    }\n  }\n\n  ;\n\n  RuleSet.prototype.selectRule = function (errors) {\n    // console.log(\"Get rule\", this.raw);\n    // Is there a conditional?\n    if (this.conditionalRule) {\n      var value = this.grammar.expand(this.conditionalRule, true); // does this value match any of the conditionals?\n\n      if (this.conditionalValues[value]) {\n        var v = this.conditionalValues[value].selectRule(errors);\n        if (v !== null && v !== undefined) return v;\n      } // No returned value?\n\n    } // Is there a ranked order?\n\n\n    if (this.ranking) {\n      for (var i = 0; i < this.ranking.length; i++) {\n        var v = this.ranking.selectRule();\n        if (v !== null && v !== undefined) return v;\n      } // Still no returned value?\n\n    }\n\n    if (this.defaultRules !== undefined) {\n      var index = 0; // Select from this basic array of rules\n      // Get the distribution from the grammar if there is no other\n\n      var distribution = this.distribution;\n      if (!distribution) distribution = this.grammar.distribution;\n\n      switch (distribution) {\n        case \"shuffle\":\n          // create a shuffle desk\n          if (!this.shuffledDeck || this.shuffledDeck.length === 0) {\n            // make an array\n            this.shuffledDeck = fyshuffle(Array.apply(null, {\n              length: this.defaultRules.length\n            }).map(Number.call, Number), this.falloff);\n          }\n\n          index = this.shuffledDeck.pop();\n          break;\n\n        case \"weighted\":\n          errors.push(\"Weighted distribution not yet implemented\");\n          break;\n\n        case \"falloff\":\n          errors.push(\"Falloff distribution not yet implemented\");\n          break;\n\n        default:\n          index = Math.floor(Math.pow(Math.random(), this.falloff) * this.defaultRules.length);\n          break;\n      }\n\n      if (!this.defaultUses) this.defaultUses = [];\n      this.defaultUses[index] = ++this.defaultUses[index] || 1;\n      return this.defaultRules[index];\n    }\n\n    errors.push(\"No default rules defined for \" + this);\n    return null;\n  };\n\n  RuleSet.prototype.clearState = function () {\n    if (this.defaultUses) {\n      this.defaultUses = [];\n    }\n  };\n\n  function fyshuffle(array, falloff) {\n    var currentIndex = array.length,\n        temporaryValue,\n        randomIndex; // While there remain elements to shuffle...\n\n    while (0 !== currentIndex) {\n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1; // And swap it with the current element.\n\n      temporaryValue = array[currentIndex];\n      array[currentIndex] = array[randomIndex];\n      array[randomIndex] = temporaryValue;\n    }\n\n    return array;\n  }\n\n  var Symbol = function (grammar, key, rawRules) {\n    // Symbols can be made with a single value, and array, or array of objects of (conditions/values)\n    this.key = key;\n    this.grammar = grammar;\n    this.rawRules = rawRules;\n    this.baseRules = new RuleSet(this.grammar, rawRules);\n    this.clearState();\n  };\n\n  Symbol.prototype.clearState = function () {\n    // Clear the stack and clear all ruleset usages\n    this.stack = [this.baseRules];\n    this.uses = [];\n    this.baseRules.clearState();\n  };\n\n  Symbol.prototype.pushRules = function (rawRules) {\n    var rules = new RuleSet(this.grammar, rawRules);\n    this.stack.push(rules);\n  };\n\n  Symbol.prototype.popRules = function () {\n    this.stack.pop();\n  };\n\n  Symbol.prototype.selectRule = function (node, errors) {\n    this.uses.push({\n      node: node\n    });\n\n    if (this.stack.length === 0) {\n      errors.push(\"The rule stack for '\" + this.key + \"' is empty, too many pops?\");\n      return \"((\" + this.key + \"))\";\n    }\n\n    return this.stack[this.stack.length - 1].selectRule();\n  };\n\n  Symbol.prototype.getActiveRules = function () {\n    if (this.stack.length === 0) {\n      return null;\n    }\n\n    return this.stack[this.stack.length - 1].selectRule();\n  };\n\n  Symbol.prototype.rulesToJSON = function () {\n    return JSON.stringify(this.rawRules);\n  };\n\n  var Grammar = function (raw, settings) {\n    this.modifiers = {};\n    this.loadFromRawObj(raw);\n  };\n\n  Grammar.prototype.clearState = function () {\n    var keys = Object.keys(this.symbols);\n\n    for (var i = 0; i < keys.length; i++) {\n      this.symbols[keys[i]].clearState();\n    }\n  };\n\n  Grammar.prototype.addModifiers = function (mods) {\n    // copy over the base modifiers\n    for (var key in mods) {\n      if (mods.hasOwnProperty(key)) {\n        this.modifiers[key] = mods[key];\n      }\n    }\n\n    ;\n  };\n\n  Grammar.prototype.loadFromRawObj = function (raw) {\n    this.raw = raw;\n    this.symbols = {};\n    this.subgrammars = [];\n\n    if (this.raw) {\n      // Add all rules to the grammar\n      for (var key in this.raw) {\n        if (this.raw.hasOwnProperty(key)) {\n          this.symbols[key] = new Symbol(this, key, this.raw[key]);\n        }\n      }\n    }\n  };\n\n  Grammar.prototype.createRoot = function (rule) {\n    // Create a node and subnodes\n    var root = new TraceryNode(this, 0, {\n      type: -1,\n      raw: rule\n    });\n    return root;\n  };\n\n  Grammar.prototype.expand = function (rule, allowEscapeChars) {\n    var root = this.createRoot(rule);\n    root.expand();\n    if (!allowEscapeChars) root.clearEscapeChars();\n    return root;\n  };\n\n  Grammar.prototype.flatten = function (rule, allowEscapeChars) {\n    var root = this.expand(rule, allowEscapeChars);\n    return root.finishedText;\n  };\n\n  Grammar.prototype.toJSON = function () {\n    var keys = Object.keys(this.symbols);\n    var symbolJSON = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      symbolJSON.push(' \"' + key + '\" : ' + this.symbols[key].rulesToJSON());\n    }\n\n    return \"{\\n\" + symbolJSON.join(\",\\n\") + \"\\n}\";\n  }; // Create or push rules\n\n\n  Grammar.prototype.pushRules = function (key, rawRules, sourceAction) {\n    if (this.symbols[key] === undefined) {\n      this.symbols[key] = new Symbol(this, key, rawRules);\n      if (sourceAction) this.symbols[key].isDynamic = true;\n    } else {\n      this.symbols[key].pushRules(rawRules);\n    }\n  };\n\n  Grammar.prototype.popRules = function (key) {\n    if (!this.symbols[key]) this.errors.push(\"Can't pop: no symbol for key \" + key);\n    this.symbols[key].popRules();\n  };\n\n  Grammar.prototype.selectRule = function (key, node, errors) {\n    if (this.symbols[key]) {\n      var rule = this.symbols[key].selectRule(node, errors);\n      return rule;\n    } // Failover to alternative subgrammars\n\n\n    for (var i = 0; i < this.subgrammars.length; i++) {\n      if (this.subgrammars[i].symbols[key]) return this.subgrammars[i].symbols[key].selectRule();\n    } // No symbol?\n\n\n    errors.push(\"No symbol for '\" + key + \"'\");\n    return \"((\" + key + \"))\";\n  }; // Parses a plaintext rule in the tracery syntax\n\n\n  tracery = {\n    createGrammar: function (raw) {\n      return new Grammar(raw);\n    },\n    // Parse the contents of a tag\n    parseTag: function (tagContents) {\n      var parsed = {\n        symbol: undefined,\n        preactions: [],\n        postactions: [],\n        modifiers: []\n      };\n      var sections = tracery.parse(tagContents);\n      var symbolSection = undefined;\n\n      for (var i = 0; i < sections.length; i++) {\n        if (sections[i].type === 0) {\n          if (symbolSection === undefined) {\n            symbolSection = sections[i].raw;\n          } else {\n            throw \"multiple main sections in \" + tagContents;\n          }\n        } else {\n          parsed.preactions.push(sections[i]);\n        }\n      }\n\n      if (symbolSection === undefined) {//   throw (\"no main section in \" + tagContents);\n      } else {\n        var components = symbolSection.split(\".\");\n        parsed.symbol = components[0];\n        parsed.modifiers = components.slice(1);\n      }\n\n      return parsed;\n    },\n    parse: function (rule) {\n      var depth = 0;\n      var inTag = false;\n      var sections = [];\n      var escaped = false;\n      var errors = [];\n      var start = 0;\n      var escapedSubstring = \"\";\n      var lastEscapedChar = undefined;\n\n      if (rule === null) {\n        var sections = [];\n        sections.errors = errors;\n        return sections;\n      }\n\n      function createSection(start, end, type) {\n        if (end - start < 1) {\n          if (type === 1) errors.push(start + \": empty tag\");\n          if (type === 2) errors.push(start + \": empty action\");\n        }\n\n        var rawSubstring;\n\n        if (lastEscapedChar !== undefined) {\n          rawSubstring = escapedSubstring + \"\\\\\" + rule.substring(lastEscapedChar + 1, end);\n        } else {\n          rawSubstring = rule.substring(start, end);\n        }\n\n        sections.push({\n          type: type,\n          raw: rawSubstring\n        });\n        lastEscapedChar = undefined;\n        escapedSubstring = \"\";\n      }\n\n      ;\n\n      for (var i = 0; i < rule.length; i++) {\n        if (!escaped) {\n          var c = rule.charAt(i);\n\n          switch (c) {\n            // Enter a deeper bracketed section\n            case '[':\n              if (depth === 0 && !inTag) {\n                if (start < i) createSection(start, i, 0);\n                start = i + 1;\n              }\n\n              depth++;\n              break;\n\n            case ']':\n              depth--; // End a bracketed section\n\n              if (depth === 0 && !inTag) {\n                createSection(start, i, 2);\n                start = i + 1;\n              }\n\n              break;\n            // Hashtag\n            //   ignore if not at depth 0, that means we are in a bracket\n\n            case '#':\n              if (depth === 0) {\n                if (inTag) {\n                  createSection(start, i, 1);\n                  start = i + 1;\n                } else {\n                  if (start < i) createSection(start, i, 0);\n                  start = i + 1;\n                }\n\n                inTag = !inTag;\n              }\n\n              break;\n\n            case '\\\\':\n              escaped = true;\n              escapedSubstring = escapedSubstring + rule.substring(start, i);\n              start = i + 1;\n              lastEscapedChar = i;\n              break;\n          }\n        } else {\n          escaped = false;\n        }\n      }\n\n      if (start < rule.length) createSection(start, rule.length, 0);\n\n      if (inTag) {\n        errors.push(\"Unclosed tag\");\n      }\n\n      if (depth > 0) {\n        errors.push(\"Too many [\");\n      }\n\n      if (depth < 0) {\n        errors.push(\"Too many ]\");\n      } // Strip out empty plaintext sections\n\n\n      sections = sections.filter(function (section) {\n        if (section.type === 0 && section.raw.length === 0) return false;\n        return true;\n      });\n      sections.errors = errors;\n      return sections;\n    }\n  };\n\n  function isVowel(c) {\n    var c2 = c.toLowerCase();\n    return c2 === 'a' || c2 === 'e' || c2 === 'i' || c2 === 'o' || c2 === 'u';\n  }\n\n  ;\n\n  function isAlphaNum(c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9';\n  }\n\n  ;\n\n  function escapeRegExp(str) {\n    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n  }\n\n  var baseEngModifiers = {\n    replace: function (s, params) {\n      //http://stackoverflow.com/questions/1144783/replacing-all-occurrences-of-a-string-in-javascript\n      return s.replace(new RegExp(escapeRegExp(params[0]), 'g'), params[1]);\n    },\n    capitalizeAll: function (s) {\n      var s2 = \"\";\n      var capNext = true;\n\n      for (var i = 0; i < s.length; i++) {\n        if (!isAlphaNum(s.charAt(i))) {\n          capNext = true;\n          s2 += s.charAt(i);\n        } else {\n          if (!capNext) {\n            s2 += s.charAt(i);\n          } else {\n            s2 += s.charAt(i).toUpperCase();\n            capNext = false;\n          }\n        }\n      }\n\n      return s2;\n    },\n    capitalize: function (s) {\n      return s.charAt(0).toUpperCase() + s.substring(1);\n    },\n    a: function (s) {\n      if (s.length > 0) {\n        if (s.charAt(0).toLowerCase() === 'u') {\n          if (s.length > 2) {\n            if (s.charAt(2).toLowerCase() === 'i') return \"a \" + s;\n          }\n        }\n\n        if (isVowel(s.charAt(0))) {\n          return \"an \" + s;\n        }\n      }\n\n      return \"a \" + s;\n    },\n    firstS: function (s) {\n      console.log(s);\n      var s2 = s.split(\" \");\n      var finished = baseEngModifiers.s(s2[0]) + \" \" + s2.slice(1).join(\" \");\n      console.log(finished);\n      return finished;\n    },\n    s: function (s) {\n      switch (s.charAt(s.length - 1)) {\n        case 's':\n          return s + \"es\";\n          break;\n\n        case 'h':\n          return s + \"es\";\n          break;\n\n        case 'x':\n          return s + \"es\";\n          break;\n\n        case 'y':\n          if (!isVowel(s.charAt(s.length - 2))) return s.substring(0, s.length - 1) + \"ies\";else return s + \"s\";\n          break;\n\n        default:\n          return s + \"s\";\n      }\n    },\n    ed: function (s) {\n      switch (s.charAt(s.length - 1)) {\n        case 's':\n          return s + \"ed\";\n          break;\n\n        case 'e':\n          return s + \"d\";\n          break;\n\n        case 'h':\n          return s + \"ed\";\n          break;\n\n        case 'x':\n          return s + \"ed\";\n          break;\n\n        case 'y':\n          if (!isVowel(s.charAt(s.length - 2))) return s.substring(0, s.length - 1) + \"ied\";else return s + \"d\";\n          break;\n\n        default:\n          return s + \"ed\";\n      }\n    }\n  };\n  tracery.baseEngModifiers = baseEngModifiers; // Externalize\n\n  tracery.TraceryNode = TraceryNode;\n  tracery.Grammar = Grammar;\n  tracery.Symbol = Symbol;\n  tracery.RuleSet = RuleSet;\n  return tracery;\n}();\n\nmodule.exports = tracery;","map":{"version":3,"sources":["/Users/katetuohy/Documents/color-palette/node_modules/tracery-grammar/tracery.js"],"names":["tracery","TraceryNode","parent","childIndex","settings","errors","raw","undefined","push","Grammar","grammar","depth","type","isExpanded","prototype","toString","expandChildren","childRule","preventRecursion","children","finishedText","sections","parse","length","concat","i","expand","expansionErrors","preactions","postactions","parsed","parseTag","symbol","modifiers","NodeAction","createUndo","activate","selectedRule","selectRule","modName","modParams","indexOf","regExp","results","exec","split","substring","mod","action","clearEscapeChars","replace","node","target","rule","ruleSections","finishedRules","ruleNodes","n","pushRules","popRules","flatten","toText","RuleSet","falloff","Array","isArray","defaultRules","String","conditionalRule","value","conditionalValues","v","ranking","index","distribution","shuffledDeck","fyshuffle","apply","map","Number","call","pop","Math","floor","pow","random","defaultUses","clearState","array","currentIndex","temporaryValue","randomIndex","Symbol","key","rawRules","baseRules","stack","uses","rules","getActiveRules","rulesToJSON","JSON","stringify","loadFromRawObj","keys","Object","symbols","addModifiers","mods","hasOwnProperty","subgrammars","createRoot","root","allowEscapeChars","toJSON","symbolJSON","join","sourceAction","isDynamic","createGrammar","tagContents","symbolSection","components","slice","inTag","escaped","start","escapedSubstring","lastEscapedChar","createSection","end","rawSubstring","c","charAt","filter","section","isVowel","c2","toLowerCase","isAlphaNum","escapeRegExp","str","baseEngModifiers","s","params","RegExp","capitalizeAll","s2","capNext","toUpperCase","capitalize","a","firstS","console","log","finished","ed","module","exports"],"mappings":"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","sourcesContent":["/**\n * @author Kate\n */\n\nvar tracery = function() {\n\n    var TraceryNode = function(parent, childIndex, settings) {\n        this.errors = [];\n\n        // No input? Add an error, but continue anyways\n        if (settings.raw === undefined) {\n            this.errors.push(\"Empty input for node\");\n            settings.raw = \"\";\n        }\n\n        // If the root node of an expansion, it will have the grammar passed as the 'parent'\n        //  set the grammar from the 'parent', and set all other values for a root node\n        if ( parent instanceof tracery.Grammar) {\n            this.grammar = parent;\n            this.parent = null;\n            this.depth = 0;\n            this.childIndex = 0;\n        } else {\n            this.grammar = parent.grammar;\n            this.parent = parent;\n            this.depth = parent.depth + 1;\n            this.childIndex = childIndex;\n        }\n\n        this.raw = settings.raw;\n        this.type = settings.type;\n        this.isExpanded = false;\n\n        if (!this.grammar) {\n            this.errors.push(\"No grammar specified for this node \" + this);\n        }\n\n    };\n\n    TraceryNode.prototype.toString = function() {\n        return \"Node('\" + this.raw + \"' \" + this.type + \" d:\" + this.depth + \")\";\n    };\n\n    // Expand the node (with the given child rule)\n    //  Make children if the node has any\n    TraceryNode.prototype.expandChildren = function(childRule, preventRecursion) {\n        this.children = [];\n        this.finishedText = \"\";\n\n        // Set the rule for making children,\n        // and expand it into section\n        this.childRule = childRule;\n        if (this.childRule !== undefined) {\n            var sections = tracery.parse(childRule);\n\n            // Add errors to this\n            if (sections.errors.length > 0) {\n                this.errors = this.errors.concat(sections.errors);\n\n            }\n\n            for (var i = 0; i < sections.length; i++) {\n                this.children[i] = new TraceryNode(this, i, sections[i]);\n                if (!preventRecursion)\n                    this.children[i].expand(preventRecursion);\n\n                // Add in the finished text\n                this.finishedText += this.children[i].finishedText;\n            }\n        } else {\n            // In normal operation, this shouldn't ever happen\n            this.errors.push(\"No child rule provided, can't expand children\");\n        }\n    };\n\n    // Expand this rule (possibly creating children)\n    TraceryNode.prototype.expand = function(preventRecursion) {\n\n        if (!this.isExpanded) {\n            this.isExpanded = true;\n\n            this.expansionErrors = [];\n\n            // Types of nodes\n            // -1: raw, needs parsing\n            //  0: Plaintext\n            //  1: Tag (\"#symbol.mod.mod2.mod3#\" or \"#[pushTarget:pushRule]symbol.mod\")\n            //  2: Action (\"[pushTarget:pushRule], [pushTarget:POP]\", more in the future)\n\n            switch(this.type) {\n            // Raw rule\n            case -1:\n\n                this.expandChildren(this.raw, preventRecursion);\n                break;\n\n            // plaintext, do nothing but copy text into finsihed text\n            case 0:\n                this.finishedText = this.raw;\n                break;\n\n            // Tag\n            case 1:\n                // Parse to find any actions, and figure out what the symbol is\n                this.preactions = [];\n                this.postactions = [];\n\n                var parsed = tracery.parseTag(this.raw);\n\n                // Break into symbol actions and modifiers\n                this.symbol = parsed.symbol;\n                this.modifiers = parsed.modifiers;\n\n                // Create all the preactions from the raw syntax\n                for (var i = 0; i < parsed.preactions.length; i++) {\n                    this.preactions[i] = new NodeAction(this, parsed.preactions[i].raw);\n                }\n                for (var i = 0; i < parsed.postactions.length; i++) {\n                    //   this.postactions[i] = new NodeAction(this, parsed.postactions[i].raw);\n                }\n\n                // Make undo actions for all preactions (pops for each push)\n                for (var i = 0; i < this.preactions.length; i++) {\n                    if (this.preactions[i].type === 0)\n                        this.postactions.push(this.preactions[i].createUndo());\n                }\n\n                // Activate all the preactions\n                for (var i = 0; i < this.preactions.length; i++) {\n                    this.preactions[i].activate();\n                }\n\n                this.finishedText = this.raw;\n\n                // Expand (passing the node, this allows tracking of recursion depth)\n\n                var selectedRule = this.grammar.selectRule(this.symbol, this, this.errors);\n\n                this.expandChildren(selectedRule, preventRecursion);\n\n                // Apply modifiers\n                // TODO: Update parse function to not trigger on hashtags within parenthesis within tags,\n                //   so that modifier parameters can contain tags \"#story.replace(#protagonist#, #newCharacter#)#\"\n                for (var i = 0; i < this.modifiers.length; i++) {\n                    var modName = this.modifiers[i];\n                    var modParams = [];\n                    if (modName.indexOf(\"(\") > 0) {\n                        var regExp = /\\(([^)]+)\\)/;\n\n                        // Todo: ignore any escaped commas.  For now, commas always split\n                        var results = regExp.exec(this.modifiers[i]);\n                        if (!results || results.length < 2) {\n                        } else {\n                            var modParams = results[1].split(\",\");\n                            modName = this.modifiers[i].substring(0, modName.indexOf(\"(\"));\n                        }\n\n                    }\n\n                    var mod = this.grammar.modifiers[modName];\n\n                    // Missing modifier?\n                    if (!mod) {\n                        this.errors.push(\"Missing modifier \" + modName);\n                        this.finishedText += \"((.\" + modName + \"))\";\n                    } else {\n                        this.finishedText = mod(this.finishedText, modParams);\n\n                    }\n\n                }\n\n                // Perform post-actions\n                for (var i = 0; i < this.postactions.length; i++) {\n                    this.postactions[i].activate();\n                }\n                break;\n            case 2:\n\n                // Just a bare action?  Expand it!\n                this.action = new NodeAction(this, this.raw);\n                this.action.activate();\n\n                // No visible text for an action\n                // TODO: some visible text for if there is a failure to perform the action?\n                this.finishedText = \"\";\n                break;\n\n            }\n\n        } else {\n            //console.warn(\"Already expanded \" + this);\n        }\n\n    };\n\n    TraceryNode.prototype.clearEscapeChars = function() {\n\n        this.finishedText = this.finishedText.replace(/\\\\\\\\/g, \"DOUBLEBACKSLASH\").replace(/\\\\/g, \"\").replace(/DOUBLEBACKSLASH/g, \"\\\\\");\n    };\n\n    // An action that occurs when a node is expanded\n    // Types of actions:\n    // 0 Push: [key:rule]\n    // 1 Pop: [key:POP]\n    // 2 function: [functionName(param0,param1)] (TODO!)\n    function NodeAction(node, raw) {\n        /*\n         if (!node)\n         console.warn(\"No node for NodeAction\");\n         if (!raw)\n         console.warn(\"No raw commands for NodeAction\");\n         */\n\n        this.node = node;\n\n        var sections = raw.split(\":\");\n        this.target = sections[0];\n\n        // No colon? A function!\n        if (sections.length === 1) {\n            this.type = 2;\n\n        }\n\n        // Colon? It's either a push or a pop\n        else {\n            this.rule = sections[1];\n            if (this.rule === \"POP\") {\n                this.type = 1;\n            } else {\n                this.type = 0;\n            }\n        }\n    }\n\n\n    NodeAction.prototype.createUndo = function() {\n        if (this.type === 0) {\n            return new NodeAction(this.node, this.target + \":POP\");\n        }\n        // TODO Not sure how to make Undo actions for functions or POPs\n        return null;\n    };\n\n    NodeAction.prototype.activate = function() {\n        var grammar = this.node.grammar;\n        switch(this.type) {\n        case 0:\n            // split into sections (the way to denote an array of rules)\n            this.ruleSections = this.rule.split(\",\");\n            this.finishedRules = [];\n            this.ruleNodes = [];\n            for (var i = 0; i < this.ruleSections.length; i++) {\n                var n = new TraceryNode(grammar, 0, {\n                    type : -1,\n                    raw : this.ruleSections[i]\n                });\n\n                n.expand();\n\n                this.finishedRules.push(n.finishedText);\n            }\n\n            // TODO: escape commas properly\n            grammar.pushRules(this.target, this.finishedRules, this);\n            break;\n        case 1:\n            grammar.popRules(this.target);\n            break;\n        case 2:\n            grammar.flatten(this.target, true);\n            break;\n        }\n\n    };\n\n    NodeAction.prototype.toText = function() {\n        switch(this.type) {\n        case 0:\n            return this.target + \":\" + this.rule;\n        case 1:\n            return this.target + \":POP\";\n        case 2:\n            return \"((some function))\";\n        default:\n            return \"((Unknown Action))\";\n        }\n    };\n\n    // Sets of rules\n    // Can also contain conditional or fallback sets of rulesets)\n    function RuleSet(grammar, raw) {\n        this.raw = raw;\n        this.grammar = grammar;\n        this.falloff = 1;\n\n        if (Array.isArray(raw)) {\n            this.defaultRules = raw;\n        } else if ( typeof raw === 'string' || raw instanceof String) {\n            this.defaultRules = [raw];\n        } else if (raw === 'object') {\n            // TODO: support for conditional and hierarchical rule sets\n        }\n\n    };\n\n    RuleSet.prototype.selectRule = function(errors) {\n        // console.log(\"Get rule\", this.raw);\n        // Is there a conditional?\n        if (this.conditionalRule) {\n            var value = this.grammar.expand(this.conditionalRule, true);\n            // does this value match any of the conditionals?\n            if (this.conditionalValues[value]) {\n                var v = this.conditionalValues[value].selectRule(errors);\n                if (v !== null && v !== undefined)\n                    return v;\n            }\n            // No returned value?\n        }\n\n        // Is there a ranked order?\n        if (this.ranking) {\n            for (var i = 0; i < this.ranking.length; i++) {\n                var v = this.ranking.selectRule();\n                if (v !== null && v !== undefined)\n                    return v;\n            }\n\n            // Still no returned value?\n        }\n\n        if (this.defaultRules !== undefined) {\n            var index = 0;\n            // Select from this basic array of rules\n\n            // Get the distribution from the grammar if there is no other\n            var distribution = this.distribution;\n            if (!distribution)\n                distribution = this.grammar.distribution;\n\n            switch(distribution) {\n            case \"shuffle\":\n\n                // create a shuffle desk\n                if (!this.shuffledDeck || this.shuffledDeck.length === 0) {\n                    // make an array\n                    this.shuffledDeck = fyshuffle(Array.apply(null, {\n                        length : this.defaultRules.length\n                    }).map(Number.call, Number), this.falloff);\n\n                }\n\n                index = this.shuffledDeck.pop();\n\n                break;\n            case \"weighted\":\n                errors.push(\"Weighted distribution not yet implemented\");\n                break;\n            case \"falloff\":\n                errors.push(\"Falloff distribution not yet implemented\");\n                break;\n            default:\n\n                index = Math.floor(Math.pow(Math.random(), this.falloff) * this.defaultRules.length);\n                break;\n            }\n\n            if (!this.defaultUses)\n                this.defaultUses = [];\n            this.defaultUses[index] = ++this.defaultUses[index] || 1;\n            return this.defaultRules[index];\n        }\n\n        errors.push(\"No default rules defined for \" + this);\n        return null;\n\n    };\n\n    RuleSet.prototype.clearState = function() {\n\n        if (this.defaultUses) {\n            this.defaultUses = [];\n        }\n    };\n\n    function fyshuffle(array, falloff) {\n        var currentIndex = array.length,\n            temporaryValue,\n            randomIndex;\n\n        // While there remain elements to shuffle...\n        while (0 !== currentIndex) {\n\n            // Pick a remaining element...\n            randomIndex = Math.floor(Math.random() * currentIndex);\n            currentIndex -= 1;\n\n            // And swap it with the current element.\n            temporaryValue = array[currentIndex];\n            array[currentIndex] = array[randomIndex];\n            array[randomIndex] = temporaryValue;\n        }\n\n        return array;\n    }\n\n    var Symbol = function(grammar, key, rawRules) {\n        // Symbols can be made with a single value, and array, or array of objects of (conditions/values)\n        this.key = key;\n        this.grammar = grammar;\n        this.rawRules = rawRules;\n\n        this.baseRules = new RuleSet(this.grammar, rawRules);\n        this.clearState();\n\n    };\n\n    Symbol.prototype.clearState = function() {\n\n        // Clear the stack and clear all ruleset usages\n        this.stack = [this.baseRules];\n\n        this.uses = [];\n        this.baseRules.clearState();\n    };\n\n    Symbol.prototype.pushRules = function(rawRules) {\n        var rules = new RuleSet(this.grammar, rawRules);\n        this.stack.push(rules);\n    };\n\n    Symbol.prototype.popRules = function() {\n        this.stack.pop();\n    };\n\n    Symbol.prototype.selectRule = function(node, errors) {\n        this.uses.push({\n            node : node\n        });\n\n        if (this.stack.length === 0) {\n            errors.push(\"The rule stack for '\" + this.key + \"' is empty, too many pops?\");\n            return \"((\" + this.key + \"))\";\n        }\n\n        return this.stack[this.stack.length - 1].selectRule();\n    };\n\n    Symbol.prototype.getActiveRules = function() {\n        if (this.stack.length === 0) {\n            return null;\n        }\n        return this.stack[this.stack.length - 1].selectRule();\n    };\n\n    Symbol.prototype.rulesToJSON = function() {\n        return JSON.stringify(this.rawRules);\n    };\n\n    var Grammar = function(raw, settings) {\n        this.modifiers = {};\n        this.loadFromRawObj(raw);\n    };\n\n    Grammar.prototype.clearState = function() {\n        var keys = Object.keys(this.symbols);\n        for (var i = 0; i < keys.length; i++) {\n            this.symbols[keys[i]].clearState();\n        }\n    };\n\n    Grammar.prototype.addModifiers = function(mods) {\n\n        // copy over the base modifiers\n        for (var key in mods) {\n            if (mods.hasOwnProperty(key)) {\n                this.modifiers[key] = mods[key];\n            }\n        };\n\n    };\n\n    Grammar.prototype.loadFromRawObj = function(raw) {\n\n        this.raw = raw;\n        this.symbols = {};\n        this.subgrammars = [];\n\n        if (this.raw) {\n            // Add all rules to the grammar\n            for (var key in this.raw) {\n                if (this.raw.hasOwnProperty(key)) {\n                    this.symbols[key] = new Symbol(this, key, this.raw[key]);\n                }\n            }\n        }\n    };\n\n    Grammar.prototype.createRoot = function(rule) {\n        // Create a node and subnodes\n        var root = new TraceryNode(this, 0, {\n            type : -1,\n            raw : rule,\n        });\n\n        return root;\n    };\n\n    Grammar.prototype.expand = function(rule, allowEscapeChars) {\n        var root = this.createRoot(rule);\n        root.expand();\n        if (!allowEscapeChars)\n            root.clearEscapeChars();\n\n        return root;\n    };\n\n    Grammar.prototype.flatten = function(rule, allowEscapeChars) {\n        var root = this.expand(rule, allowEscapeChars);\n\n        return root.finishedText;\n    };\n\n    Grammar.prototype.toJSON = function() {\n        var keys = Object.keys(this.symbols);\n        var symbolJSON = [];\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            symbolJSON.push(' \"' + key + '\" : ' + this.symbols[key].rulesToJSON());\n        }\n        return \"{\\n\" + symbolJSON.join(\",\\n\") + \"\\n}\";\n    };\n\n    // Create or push rules\n    Grammar.prototype.pushRules = function(key, rawRules, sourceAction) {\n\n        if (this.symbols[key] === undefined) {\n            this.symbols[key] = new Symbol(this, key, rawRules);\n            if (sourceAction)\n                this.symbols[key].isDynamic = true;\n        } else {\n            this.symbols[key].pushRules(rawRules);\n        }\n    };\n\n    Grammar.prototype.popRules = function(key) {\n        if (!this.symbols[key])\n            this.errors.push(\"Can't pop: no symbol for key \" + key);\n        this.symbols[key].popRules();\n    };\n\n    Grammar.prototype.selectRule = function(key, node, errors) {\n        if (this.symbols[key]) {\n            var rule = this.symbols[key].selectRule(node, errors);\n\n            return rule;\n        }\n\n        // Failover to alternative subgrammars\n        for (var i = 0; i < this.subgrammars.length; i++) {\n\n            if (this.subgrammars[i].symbols[key])\n                return this.subgrammars[i].symbols[key].selectRule();\n        }\n\n        // No symbol?\n        errors.push(\"No symbol for '\" + key + \"'\");\n        return \"((\" + key + \"))\";\n    };\n\n    // Parses a plaintext rule in the tracery syntax\n    tracery = {\n\n        createGrammar : function(raw) {\n            return new Grammar(raw);\n        },\n\n        // Parse the contents of a tag\n        parseTag : function(tagContents) {\n\n            var parsed = {\n                symbol : undefined,\n                preactions : [],\n                postactions : [],\n                modifiers : []\n            };\n            var sections = tracery.parse(tagContents);\n            var symbolSection = undefined;\n            for (var i = 0; i < sections.length; i++) {\n                if (sections[i].type === 0) {\n                    if (symbolSection === undefined) {\n                        symbolSection = sections[i].raw;\n                    } else {\n                        throw (\"multiple main sections in \" + tagContents);\n                    }\n                } else {\n                    parsed.preactions.push(sections[i]);\n                }\n            }\n\n            if (symbolSection === undefined) {\n                //   throw (\"no main section in \" + tagContents);\n            } else {\n                var components = symbolSection.split(\".\");\n                parsed.symbol = components[0];\n                parsed.modifiers = components.slice(1);\n            }\n            return parsed;\n        },\n\n        parse : function(rule) {\n            var depth = 0;\n            var inTag = false;\n            var sections = [];\n            var escaped = false;\n\n            var errors = [];\n            var start = 0;\n\n            var escapedSubstring = \"\";\n            var lastEscapedChar = undefined;\n\n            if (rule === null) {\n                var sections = [];\n                sections.errors = errors;\n\n                return sections;\n            }\n\n            function createSection(start, end, type) {\n                if (end - start < 1) {\n                    if (type === 1)\n                        errors.push(start + \": empty tag\");\n                    if (type === 2)\n                        errors.push(start + \": empty action\");\n\n                }\n                var rawSubstring;\n                if (lastEscapedChar !== undefined) {\n                    rawSubstring = escapedSubstring + \"\\\\\" + rule.substring(lastEscapedChar + 1, end);\n\n                } else {\n                    rawSubstring = rule.substring(start, end);\n                }\n                sections.push({\n                    type : type,\n                    raw : rawSubstring\n                });\n                lastEscapedChar = undefined;\n                escapedSubstring = \"\";\n            };\n\n            for (var i = 0; i < rule.length; i++) {\n\n                if (!escaped) {\n                    var c = rule.charAt(i);\n\n                    switch(c) {\n\n                    // Enter a deeper bracketed section\n                    case '[':\n                        if (depth === 0 && !inTag) {\n                            if (start < i)\n                                createSection(start, i, 0);\n                            start = i + 1;\n                        }\n                        depth++;\n                        break;\n\n                    case ']':\n                        depth--;\n\n                        // End a bracketed section\n                        if (depth === 0 && !inTag) {\n                            createSection(start, i, 2);\n                            start = i + 1;\n                        }\n                        break;\n\n                    // Hashtag\n                    //   ignore if not at depth 0, that means we are in a bracket\n                    case '#':\n                        if (depth === 0) {\n                            if (inTag) {\n                                createSection(start, i, 1);\n                                start = i + 1;\n                            } else {\n                                if (start < i)\n                                    createSection(start, i, 0);\n                                start = i + 1;\n                            }\n                            inTag = !inTag;\n                        }\n                        break;\n\n                    case '\\\\':\n                        escaped = true;\n                        escapedSubstring = escapedSubstring + rule.substring(start, i);\n                        start = i + 1;\n                        lastEscapedChar = i;\n                        break;\n                    }\n                } else {\n                    escaped = false;\n                }\n            }\n            if (start < rule.length)\n                createSection(start, rule.length, 0);\n\n            if (inTag) {\n                errors.push(\"Unclosed tag\");\n            }\n            if (depth > 0) {\n                errors.push(\"Too many [\");\n            }\n            if (depth < 0) {\n                errors.push(\"Too many ]\");\n            }\n\n            // Strip out empty plaintext sections\n\n            sections = sections.filter(function(section) {\n                if (section.type === 0 && section.raw.length === 0)\n                    return false;\n                return true;\n            });\n            sections.errors = errors;\n            return sections;\n        },\n    };\n\n    function isVowel(c) {\n        var c2 = c.toLowerCase();\n        return (c2 === 'a') || (c2 === 'e') || (c2 === 'i') || (c2 === 'o') || (c2 === 'u');\n    };\n\n    function isAlphaNum(c) {\n        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');\n    };\n    function escapeRegExp(str) {\n        return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n    }\n\n    var baseEngModifiers = {\n\n        replace : function(s, params) {\n            //http://stackoverflow.com/questions/1144783/replacing-all-occurrences-of-a-string-in-javascript\n            return s.replace(new RegExp(escapeRegExp(params[0]), 'g'), params[1]);\n        },\n\n        capitalizeAll : function(s) {\n            var s2 = \"\";\n            var capNext = true;\n            for (var i = 0; i < s.length; i++) {\n\n                if (!isAlphaNum(s.charAt(i))) {\n                    capNext = true;\n                    s2 += s.charAt(i);\n                } else {\n                    if (!capNext) {\n                        s2 += s.charAt(i);\n                    } else {\n                        s2 += s.charAt(i).toUpperCase();\n                        capNext = false;\n                    }\n\n                }\n            }\n            return s2;\n        },\n\n        capitalize : function(s) {\n            return s.charAt(0).toUpperCase() + s.substring(1);\n        },\n\n        a : function(s) {\n            if (s.length > 0) {\n                if (s.charAt(0).toLowerCase() === 'u') {\n                    if (s.length > 2) {\n                        if (s.charAt(2).toLowerCase() === 'i')\n                            return \"a \" + s;\n                    }\n                }\n\n                if (isVowel(s.charAt(0))) {\n                    return \"an \" + s;\n                }\n            }\n\n            return \"a \" + s;\n\n        },\n\n        firstS : function(s) {\n            console.log(s);\n            var s2 = s.split(\" \");\n\n            var finished = baseEngModifiers.s(s2[0]) + \" \" + s2.slice(1).join(\" \");\n            console.log(finished);\n            return finished;\n        },\n\n        s : function(s) {\n            switch (s.charAt(s.length -1)) {\n            case 's':\n                return s + \"es\";\n                break;\n            case 'h':\n                return s + \"es\";\n                break;\n            case 'x':\n                return s + \"es\";\n                break;\n            case 'y':\n                if (!isVowel(s.charAt(s.length - 2)))\n                    return s.substring(0, s.length - 1) + \"ies\";\n                else\n                    return s + \"s\";\n                break;\n            default:\n                return s + \"s\";\n            }\n        },\n        ed : function(s) {\n            switch (s.charAt(s.length -1)) {\n            case 's':\n                return s + \"ed\";\n                break;\n            case 'e':\n                return s + \"d\";\n                break;\n            case 'h':\n                return s + \"ed\";\n                break;\n            case 'x':\n                return s + \"ed\";\n                break;\n            case 'y':\n                if (!isVowel(s.charAt(s.length - 2)))\n                    return s.substring(0, s.length - 1) + \"ied\";\n                else\n                    return s + \"d\";\n                break;\n            default:\n                return s + \"ed\";\n            }\n        }\n    };\n\n    tracery.baseEngModifiers = baseEngModifiers; \n    // Externalize\n    tracery.TraceryNode = TraceryNode;\n\n    tracery.Grammar = Grammar;\n    tracery.Symbol = Symbol;\n    tracery.RuleSet = RuleSet;\n    return tracery;\n}();\n\nmodule.exports = tracery; "]},"metadata":{},"sourceType":"script"}